# Creating and Sending Transactions

This guide shows how to create, sign, and send transactions using the APL SDK.

## Prerequisites

```typescript
import { 
  createRpcConnection,
  createSignerFromKeypair,
  transferTx,
  MintUtil,
  AssociatedTokenUtil,
  waitForConfirmation
} from '@repo/apl-sdk';

const rpcConnection = createRpcConnection('YOUR_RPC_URL');
```

## Token Transfer Example

Here's a complete example of transferring tokens:

```typescript
async function transferTokens(
  sourceKeypair: Keypair,
  recipientAddress: string,
  mintAddress: string,
  amount: bigint
) {
  try {
    // Convert addresses to public keys
    const recipientPubkey = Buffer.from(recipientAddress, 'hex');
    const mintPubkey = Buffer.from(mintAddress, 'hex');

    // Derive associated token accounts
    const sourceTokenPubkey = AssociatedTokenUtil.getAssociatedTokenAddress(
      mintPubkey,
      sourceKeypair.publicKey
    );
    const recipientTokenPubkey = AssociatedTokenUtil.getAssociatedTokenAddress(
      mintPubkey,
      recipientPubkey
    );

    // Verify accounts exist
    console.log('Verifying token accounts...');
    const sourceTokenInfo = await rpcConnection.readAccountInfo(sourceTokenPubkey);
    if (!sourceTokenInfo?.data) {
      throw new Error('Source token account does not exist');
    }

    const recipientTokenInfo = await rpcConnection.readAccountInfo(recipientTokenPubkey);
    if (!recipientTokenInfo?.data) {
      throw new Error('Recipient token account does not exist');
    }

    // Get mint decimals
    const mintInfo = await rpcConnection.readAccountInfo(mintPubkey);
    if (!mintInfo?.data) {
      throw new Error('Invalid or uninitialized mint account');
    }
    const mintData = MintUtil.deserialize(Buffer.from(mintInfo.data));
    const decimals = mintData.decimals;

    // Create signer from keypair
    const signer = createSignerFromKeypair(sourceKeypair);

    // Create transfer transaction
    console.log('Creating transfer transaction...');
    const tx = await transferTx(
      sourceTokenPubkey,
      mintPubkey,
      recipientTokenPubkey,
      sourceKeypair.publicKey,
      amount,
      decimals,
      signer
    );

    // Send transaction and wait for confirmation
    const result = await rpcConnection.sendTransaction(tx);
    await waitForConfirmation(rpcConnection, result);
    
    return result;
  } catch (error) {
    console.error('Transfer failed:', error);
    throw error;
  }
}
```

## Web Browser Example

For web applications, you'll need to implement a signer that works with your web wallet:

```typescript
// Example web wallet signer
const webSigner = {
  signMessage: async (message: Uint8Array) => {
    // Implementation using web wallet (e.g., LaserEyes)
    return await window.wallet.signMessage(message);
  }
};

// Use the web signer in transactions
const tx = await transferTx(
  sourceTokenPubkey,
  mintPubkey,
  recipientTokenPubkey,
  ownerPubkey,
  amount,
  decimals,
  webSigner
);
```

## Error Handling

Implement proper error handling for transactions:

```typescript
try {
  // Create and send transaction
  const tx = await transferTx(/* ... */);
  const result = await rpcConnection.sendTransaction(tx);
  
  // Wait for confirmation with timeout
  try {
    await Promise.race([
      waitForConfirmation(rpcConnection, result),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Transaction timeout')), 30000)
      )
    ]);
  } catch (error) {
    if (error.message === 'Transaction timeout') {
      // Handle timeout
      console.error('Transaction timed out');
    }
    throw error;
  }
  
} catch (error) {
  if (error.message.includes('insufficient funds')) {
    // Handle insufficient balance
  } else if (error.message.includes('Account not found')) {
    // Handle missing accounts
  } else {
    // Handle other errors
    console.error('Transaction failed:', error);
  }
}
```

## Type Definitions

For TypeScript users, here are the relevant types:

```typescript
interface SignerCallback {
  signMessage: (message: Uint8Array) => Promise<Uint8Array>;
}

interface RuntimeTransaction {
  message: Uint8Array;
  signatures: Uint8Array[];
}

interface RpcConnection {
  sendTransaction: (tx: RuntimeTransaction) => Promise<string>;
  readAccountInfo: (pubkey: Uint8Array) => Promise<AccountInfo | null>;
}
```

## Best Practices

1. Always verify accounts exist before creating transactions
2. Use try/catch blocks for error handling
3. Wait for transaction confirmation
4. Implement proper timeout handling
5. Use BigInt for token amounts
6. Validate all input addresses
7. Test signing callbacks thoroughly
